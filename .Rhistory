##' @author Robin Elahi
##' @contact elahi.robin@gmail.com
##'
##' @date 2017-08-21
##'
##' @log
################################################################################
rm(list=ls(all=TRUE))
# Get function to load data
source("sbs_bayes/sbs_load_data.R")
datJ <- load_sbs_data(min_cutoff = TRUE)
# Remove all but datJ
rm(list = setdiff(ls(), "datJ"))
## Analyze species separately
## Use group level effects for Littorina and Lottia
## For Chlorostoma, analyze sites separately
## Make separate dataframes
# Littorina keenae
childsDF <- droplevels(filter(datJ, sp == "LIKE"))
childsPast <- childsDF %>% filter(era == "past")
childsPres <- childsDF %>% filter(era == "present")
# Chlorostoma funebralis
waraDF <- droplevels(filter(datJ, sp == "CHFU"))
waraPast <- waraDF %>% filter(era == "past")
waraPres <- waraDF %>% filter(era == "present")
# Lottia digitalis
hexDF <- droplevels(filter(datJ, sp == "LODI"))
hexPast <- hexDF %>% filter(era == "past")
hexPres <- hexDF %>% filter(era == "present")
##### PREDICTING NEW DATA #####
### Create range of tidal height values for prediction
thc <- scale(datJ$sample_area_tidal_ht, scale = FALSE)
mu_th <- mean(datJ$sample_area_tidal_ht)
sd_th <- sd(datJ$sample_area_tidal_ht)
th_predict <- seq(min(datJ$sample_area_tidal_ht) * 0.95,
max(datJ$sample_area_tidal_ht * 1.05), by = 0.05)
thc_predict <- th_predict - mu_th
dat <- childsDF
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa",
"y.new", "p.mean", "p.sd", "p.discrep", "y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
source("sbs_bayes/model_hier3_normal.R")
median_change <- function(dat){
dat_summary <- dat %>% group_by(era) %>%
summarise(size_median = median(size1mm, na.rm = TRUE))
test_stat <- 1 - (dat_summary$size_median[2]/dat_summary$size_median[1])
return(test_stat)
}
n.adapt <- 3000
n.update <- 3000
n.iter <- 3000
n_chains <- 2
era_predict <- c(0,1)
pred_df <- expand.grid(thc_predict, era_predict) %>%
rename(thc_predict = Var1, era_predict = Var2)
dat <- childsDF
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa",
"y.new", "p.mean", "p.sd", "p.discrep", "y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
gelman.diag(zm, multivariate = F)
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
summary(zm)
gelman.diag(zm, multivariate = F)
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
summary(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
################################################################################
##' @title Hierarchical intercept and slope model; with tidal covariate - normal distribution
##'
##' @author Robin Elahi
##' @contact elahi.robin@gmail.com
##'
##' @date 2017-09-04
##'
##' @log
################################################################################
# rm(list=ls(all=TRUE))
hier3_model <- function(dat, iter_adapt, iter_update, n_chains){
# load jags
library(rjags)
# Create sample area groups
dat <- dat %>% mutate(group_j = as.integer(as.factor(sampleArea)))
y.n.sites = length(unique(dat$group_j))
# Create matrix for group level intercept and slope
B = matrix(nrow = y.n.sites, ncol = 2)
B[, 1] = 0
B[, 2] = 1.5
## Get data
data = list(
y = as.double(log(dat$size1mm)),
k = as.double(length(dat$size1mm)),
thc = as.double(dat$thc),
era = as.double(dat$eraJ),
y.group = dat$group_j,
y.n.sites = length(unique(dat$group_j)),
thc_predict = as.double(pred_df$thc_predict),
era_predict = as.double(pred_df$era_predict)
#group_predict = as.double(pred_df$group_predict)
)
## Iterations
n.adapt = iter_adapt
n.update = iter_update
## Inits
if(n_chains == 1){
inits = list(
B = B,
sigma = 1,
mu.alpha = runif(1, 0, 5),
mu.beta = runif(1, -10, 10),
sigma.alpha = 1,
sigma.beta = 1,
rho = -0.5,
eta = 2,
kappa = 1)
}
if(n_chains == 2){
inits = list(
list(
B = B,
sigma = 1,
mu.alpha = runif(1, 0, 5),
mu.beta = runif(1, -10, 10),
sigma.alpha = 1,
sigma.beta = 1,
rho = -0.5,
eta = 2,
kappa = 1),
list(
B = B*0.5,
sigma = 10,
mu.alpha = runif(1, 0, 5),
mu.beta = runif(1, -10, 10),
sigma.alpha = 5,
sigma.beta = 5,
rho = 0.5,
eta = -1,
kappa = -3)
)
}
## JAGS model
sink("sbs_bayes/models/hier3_normal_JAGS.R")
cat("
model{
# priors for within site model (process)
sigma ~ dunif(0, 100)
tau <- 1/sigma^2
eta ~ dnorm(0, 1/5^2)
kappa ~ dnorm(0, 1/5^2)
### priors for intercept and slope model
for(j in 1:y.n.sites){
alpha[j] <- B[j, 1] # group level intercept
beta[j] <- B[j, 2] # group level slope
B[j, 1:2] ~ dmnorm(B.hat[j, 1:2], Tau.B)
B.hat[j, 1] <- mu.alpha # required by JAGS syntax
B.hat[j, 2] <- mu.beta # required by JAGS syntax
}
mu.alpha ~ dnorm(0, 1/5^2)
mu.beta ~ dnorm(0, 1/10^2)
# Inverse of covariance matrix required by JAGS
Tau.B[1:2, 1:2] <- inverse(Sigma.B[1:2, 1:2])
# Elements of covariance matrix
Sigma.B[1,1] <- sigma.alpha^2
sigma.alpha ~ dunif(0, 100)
Sigma.B[2,2] <- sigma.beta^2
sigma.beta ~ dunif(0, 100)
Sigma.B[1,2] <- rho * sigma.alpha * sigma.beta
Sigma.B[2,1] <- Sigma.B[1,2]
rho ~ dunif(-1, 1)
# likelihood
for(i in 1:length(y)){
mu[i] <- alpha[y.group[i]] + beta[y.group[i]]*era[i] + eta*thc[i] + kappa*thc[i]*era[i]
y[i] ~ dnorm(mu[i], tau)
# Simulated data for posterior predictive checks
y.new[i] ~ dnorm(mu[i], tau)
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
#Bayesian P values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(thc_predict)){
# y_pred[j] <- alpha[group_predict[j]] + beta[group_predict[j]]*era_predict[j] + eta*thc_predict[j] + kappa*thc_predict[j]*era_predict[j]
# beta_pred[j] <- y_pred[j] - alpha[group_predict[j]] - eta*thc_predict[j]
y_pred[j] <- mu.alpha + mu.beta*era_predict[j] + eta*thc_predict[j] + kappa*thc_predict[j]*era_predict[j]
beta_pred[j] <- y_pred[j] - mu.alpha - eta*thc_predict[j]
}
}
", fill = TRUE)
sink()
jm = jags.model("sbs_bayes/models/hier3_normal_JAGS.R", data = data, inits = inits,
n.chains = length(inits), n.adapt = n.adapt)
update(jm, n.iter = n.update)
return(jm)
}
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(log(dat$size1mm), breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
################################################################################
##' @title Prepare snail data
##'
##' @author Robin Elahi
##' @contact elahi.robin@gmail.com
##'
##' @date 2017-08-21
##'
##' @log
################################################################################
rm(list=ls(all=TRUE))
# Get function to load data
source("sbs_bayes/sbs_load_data.R")
datJ <- load_sbs_data(min_cutoff = FALSE)
# Remove all but datJ
rm(list = setdiff(ls(), "datJ"))
## Analyze species separately
## Use group level effects for Littorina and Lottia
## For Chlorostoma, analyze sites separately
## Make separate dataframes
# Littorina keenae
childsDF <- droplevels(filter(datJ, sp == "LIKE"))
childsPast <- childsDF %>% filter(era == "past")
childsPres <- childsDF %>% filter(era == "present")
# Chlorostoma funebralis
waraDF <- droplevels(filter(datJ, sp == "CHFU"))
waraPast <- waraDF %>% filter(era == "past")
waraPres <- waraDF %>% filter(era == "present")
# Lottia digitalis
hexDF <- droplevels(filter(datJ, sp == "LODI"))
hexPast <- hexDF %>% filter(era == "past")
hexPres <- hexDF %>% filter(era == "present")
##### PREDICTING NEW DATA #####
### Create range of tidal height values for prediction
thc <- scale(datJ$sample_area_tidal_ht, scale = FALSE)
mu_th <- mean(datJ$sample_area_tidal_ht)
sd_th <- sd(datJ$sample_area_tidal_ht)
th_predict <- seq(min(datJ$sample_area_tidal_ht) * 0.95,
max(datJ$sample_area_tidal_ht * 1.05), by = 0.05)
thc_predict <- th_predict - mu_th
source("sbs_bayes/model_hier3_normal.R")
median_change <- function(dat){
dat_summary <- dat %>% group_by(era) %>%
summarise(size_median = median(size1mm, na.rm = TRUE))
test_stat <- 1 - (dat_summary$size_median[2]/dat_summary$size_median[1])
return(test_stat)
}
n.adapt <- 3000
n.update <- 3000
n.iter <- 3000
n_chains <- 2
era_predict <- c(0,1)
pred_df <- expand.grid(thc_predict, era_predict) %>%
rename(thc_predict = Var1, era_predict = Var2)
dat <- hexDF
dat <- childsDF
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(log(dat$size1mm), breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa",
"y.new", "p.mean", "p.sd", "p.discrep", "y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(log(dat$size1mm), breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
coda_summary <- summary(zm)
childs_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "LIKE",
param = rownames(coda_summary$quantile))
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size1mm, color = era), alpha = 0.5)
xy %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line()
xy %>%
filter(th > 1.5 & th < 8) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line()
xy %>%
filter(th > 1.5 & th < 8) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5)
xy %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size1mm, color = era), alpha = 0.5)
xy %>%
filter(th > 2 & th < 7) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size1mm, color = era), alpha = 0.5)
xy %>%
filter(th > 2 & th < 7) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5)
View(xy)
xy %>%
filter(th > 2 & th < 7) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line()
y <- summary(zj$beta_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th)
xy %>%
filter(era == "present") %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = X50., color = NULL, group = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5.),
fill = "gray", alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray")
dat <- hexDF
# Create sample area groups
# dat <- dat %>% mutate(group_j = as.integer(as.factor(sampleArea)))
# group_predict <- unique(dat$group_j)
# pred_df <- expand.grid(thc_predict, era_predict, group_predict) %>%
#   rename(thc_predict = Var1, era_predict = Var2, group_predict = Var3)
# Run model
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa",
"y.new", "p.mean", "p.sd", "p.discrep", "y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(log(dat$size1mm), breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
coda_summary <- summary(zm)
hex_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "LODI",
param = rownames(coda_summary$quantile))
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size1mm, color = era), alpha = 0.5)
y <- summary(zj$beta_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th)
xy %>%
filter(era == "present") %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = X50., color = NULL, group = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5.),
fill = "gray", alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray")
n.adapt <- 6000
n.update <- 6000
n.iter <- 6000
dat <- childsDF
start_time <- proc.time()
jm = hier3_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "mu.alpha", "mu.beta", "eta", "kappa",
"y.new", "p.mean", "p.sd", "p.discrep", "y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(log(dat$size1mm), breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
coda_summary <- summary(zm)
childs_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "LIKE",
param = rownames(coda_summary$quantile))
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 2 & th < 7) %>%
ggplot(aes(x = th, y = size_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = size_lower, ymax = size_upper, color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size1mm, color = era), alpha = 0.5)
y <- summary(zj$beta_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th)
xy %>%
filter(era == "present") %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = X50., color = NULL, group = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5.),
fill = "gray", alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray")
