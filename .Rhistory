theme(legend.position = "none")
## Boxplot
dat3 %>%
ggplot(aes(era, size1mm, fill = era)) +
geom_violin(alpha = 0.5) +
geom_boxplot() +
facet_wrap( ~ species) +
scale_fill_manual(values = c("red", "black")) +
xlab("") +
ylab("Size (mm)") +
theme(legend.position = "none") +
geom_text(data = facet_panels, aes(0, 0.15, label = facet_labels),
inherit.aes = FALSE, size = 6, nudge_x = 1, nudge_y = 0.01) +
geom_text(data = facet_panels, aes(15, 0.115, label = past_text),
inherit.aes = FALSE, size = 4, nudge_x = 1, nudge_y = 0.01, color = "red", hjust = 0) +
geom_text(data = facet_panels, aes(15, 0.1, label = present_text),
inherit.aes = FALSE, size = 4, nudge_x = 1, nudge_y = 0.01, color = "black", hjust = 0)
dat3 %>%
ggplot(aes(era, size1mm, fill = era)) +
geom_violin(alpha = 0.5) +
geom_boxplot() +
facet_wrap( ~ species) +
scale_fill_manual(values = c("red", "black")) +
xlab("") +
ylab("Size (mm)") +
theme(legend.position = "none")
## Boxplot
dat3 %>%
ggplot(aes(era, size1mm, fill = era)) +
#geom_violin(alpha = 0.5) +
geom_boxplot() +
facet_wrap( ~ species) +
scale_fill_manual(values = c("red", "black")) +
xlab("") +
ylab("Size (mm)") +
theme(legend.position = "none") +
geom_text(data = facet_panels, aes(0, 0.15, label = facet_labels),
inherit.aes = FALSE, size = 6, nudge_x = 1, nudge_y = 0.01) +
geom_text(data = facet_panels, aes(15, 0.115, label = past_text),
inherit.aes = FALSE, size = 4, nudge_x = 1, nudge_y = 0.01, color = "red", hjust = 0) +
geom_text(data = facet_panels, aes(15, 0.1, label = present_text),
inherit.aes = FALSE, size = 4, nudge_x = 1, nudge_y = 0.01, color = "black", hjust = 0)
## Boxplot
dat3 %>%
ggplot(aes(era, size1mm, fill = era)) +
#geom_violin(alpha = 0.5) +
geom_boxplot() +
facet_wrap( ~ species) +
scale_fill_manual(values = c("red", "black")) +
xlab("") +
ylab("Size (mm)") +
theme(legend.position = "none")
dat3 %>%
ggplot(aes(era, size1mm, color = era)) +
#geom_violin(alpha = 0.5) +
geom_boxplot() +
facet_wrap( ~ species) +
scale_fill_manual(values = c("red", "black")) +
xlab("") +
ylab("Size (mm)") +
theme(legend.position = "none")
##### PACKAGES, DATA #####
source("3_analyse_data/01_sbs_bayes_data.R")
source("R/truncate_data.R")
library(rjags)
library(rstan)
## My data
statDat <- childsDF
## My quantile for size threshold
my_quantile <- 0
statDat <- truncate_data(statDat, era = "past", quant = my_quantile)
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
## My species
my_species <- "LIKE"
## My data type
my_data <- "raw"
statDat
unique(statDat$site)
## Create groups for multilevel model
unique(statDat$nest1)
statDat <- statDat %>% mutate(group_j = as.integer(as.factor(nest1))) #!!! CHANGE
y.n.sites = length(unique(dat$group_j))
n_group_j = length(unique(statDat$group_j))
n_group_j
## My species
my_species <- "LIKE"
## My data type
my_data <- "raw"
# Get means and sd of continuous variables
x2_mu <- mean(statDat$density_m2)
x2_sd <- sd(statDat$density_m2)
x3_mu <- mean(statDat$tideHTm)
x3_sd <- sd(statDat$tideHTm)
# Standardize continuous variables
statDat$x2z <- as.numeric(scale(statDat$density_m2))
statDat$x3z <- as.numeric(scale(statDat$tideHTm))
make_predict_vector <- function(my_vector, predict_length = 100){
my_min <- min(my_vector)
my_max <- max(my_vector)
my_vector_pred <- seq(my_min, my_max, length.out = predict_length)
return(my_vector_pred)
}
x2z_pred <- make_predict_vector(statDat$x2z, predict_length = 100)
x3z_pred <- make_predict_vector(statDat$x3z, predict_length = 100)
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x2z_pred, era_predict) %>%
rename(x2z = Var1, x1 = Var2) %>% tbl_df()
pred_df$x3z <- 0
library(lmer)
library(lme4)
library(rstanarm)
library(brms)
install.packages("brms")
install.packages("brms")
names(statDat)
lm1 <- lm(size_log ~ era01, data = statDat)
summary(lm1)
plot(lm1)
library(ggplot2)
statDat %>%
ggplot(aes(size_log, fill = era)) +
geom_density()
statDat %>%
ggplot(aes(size_log, fill = era)) +
geom_density(alpha = 0.5)
statDat %>%
ggplot(aes(size1mm, fill = era)) +
geom_density(alpha = 0.5)
statDat %>%
ggplot(aes(size_log, fill = era)) +
geom_density(alpha = 0.5)
##' Partially pooled model (with random intercept for each group)
lmer1 <- lmer(size_log ~ era01 + (1 | group_j))
##' Partially pooled model (with random intercept for each group)
lmer1 <- lmer(size_log ~ era01 + (1 | group_j), data = statDat)
summary(lmer1)
summary(lm1)
summary(lmer1)
plot(lmer1)
library(sjplot)
library(sjPlot)
sjplot(lmer1)
?sjplot
sjp.lmer(lmer1)
sjp.lmer(lmer1, type = "re")
sjp.lmer(lmer1, type = "fe")
sjp.lmer(lmer1, type = "fe", p.kr = F)
sjp.lmer(lmer1, type = "re", p.kr = F)
CORES <- 4
plot(lm1)
alpha_observed
alpha_observed <- mean(statDat$size_log)
alpha_observed
alpha_prior <- normal(alpha_observed, 0.5)  # weakly informative prior on log-size
alpha_prior
SEED <- 101
alpha_observed <- mean(statDat$size_log)
alpha_prior <- normal(alpha_observed, 0.5)  # weakly informative prior on log-size
?stan_lmer
intercept_observed <- mean(statDat$size_log)
intercept_prior <- normal(intercept_observed, 0.5)  # weakly informative prior on log-size
intercept_observed <- mean(statDat$size_log)
intercept_prior <- normal(intercept_observed, 0.5)  # weakly informative prior on log-size
fit_hier1 <- stan_lmer(cbind(size_log, era01) ~ (1 | group_j), data = statDat,
prior_intercept = intercept_prior, cores = CORES, seed = SEED)
fit_hier1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat,
prior_intercept = intercept_prior, cores = CORES, seed = SEED)
intercept_observed <- mean(statDat$size_log)
intercept_prior <- normal(intercept_observed, 0.5)  # weakly informative prior on log-size
intercept_prior
fit_hier1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat)
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat)
stan1 <- stan_lmer(size_log ~ era + (1 | group_j), data = statDat)
stan1 <- stan_lmer(size_log ~ era01 + (1 | nest1), data = statDat)
##' Partially pooled model (with random intercept for each group)
lmer1 <- lmer(size_log ~ era01 + (1 | nest1), data = statDat)
summary(lmer1)
sjp.lmer(lmer1, type = "re", p.kr = F)
sjp.lmer(lmer1, type = "fe", p.kr = F)
stan1 <- stan_lmer(size_log ~ era01 + (1 | nest1), data = statDat)
stan1 <- stan_lmer(size_log ~ era + (1 | group_j), data = statDat)
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat)
intercept_prior
sjp.lmer(lmer1, type = "fe", p.kr = F)
sjp.lmer(lmer1, type = "re", p.kr = F)
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat)
install.packages("rstanarm", dependencies = TRUE)
library(rstanarm)
example(example_model)
################################################################################
##' @title Analyze log size - LIKE
##'
##' @author Robin Elahi
##' @contact elahi.robin@gmail.com
##'
##' @date 2017-12-17
##'
##' @log
################################################################################
##' The goal of this script is to compare pooled vs hierarchical model for Littorina keenae
##' In this case, I will use 4 groups (which may be too few)
##### PACKAGES, DATA #####
source("3_analyse_data/01_sbs_bayes_data.R")
source("R/truncate_data.R")
library(lme4)
library(rjags)
library(rstan)
library(rstanarm)
library(brms)
library(ggplot2)
library(sjPlot)
##### PREPARE DATA #####
##' x1 = era
##' x2 = density
##' x3 = tide height
## My data
statDat <- childsDF
## My quantile for size threshold
my_quantile <- 0
statDat <- truncate_data(statDat, era = "past", quant = my_quantile)
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
## Create groups for multilevel model
unique(statDat$nest1)
statDat <- statDat %>% mutate(group_j = as.integer(as.factor(nest1))) #!!! CHANGE
n_group_j = length(unique(statDat$group_j))
## My species
my_species <- "LIKE"
## My data type
my_data <- "raw"
# Get means and sd of continuous variables
x2_mu <- mean(statDat$density_m2)
x2_sd <- sd(statDat$density_m2)
x3_mu <- mean(statDat$tideHTm)
x3_sd <- sd(statDat$tideHTm)
# Standardize continuous variables
statDat$x2z <- as.numeric(scale(statDat$density_m2))
statDat$x3z <- as.numeric(scale(statDat$tideHTm))
make_predict_vector <- function(my_vector, predict_length = 100){
my_min <- min(my_vector)
my_max <- max(my_vector)
my_vector_pred <- seq(my_min, my_max, length.out = predict_length)
return(my_vector_pred)
}
x2z_pred <- make_predict_vector(statDat$x2z, predict_length = 100)
x3z_pred <- make_predict_vector(statDat$x3z, predict_length = 100)
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x2z_pred, era_predict) %>%
rename(x2z = Var1, x1 = Var2) %>% tbl_df()
pred_df$x3z <- 0
statDat %>%
ggplot(aes(size1mm, fill = era)) +
geom_density(alpha = 0.5)
statDat %>%
ggplot(aes(size_log, fill = era)) +
geom_density(alpha = 0.5)
##### LMER #####
##' Pooled model
lm1 <- lm(size_log ~ era01, data = statDat)
summary(lm1)
plot(lm1)
sjp.lmer(lmer1, type = "re", p.kr = F)
sjp.lmer(lmer1, type = "fe", p.kr = F)
##### RSTAN #####
lmer1 <- lmer(size_log ~ era01 + (1 | group_j), data = statDat)
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat)
stan1
summary(lmer1)
apply(stan1, 2, quantile, probs = c(0.1, 0.5, 0.9))
stan1
summary(stan1)
pairs()
pp_check(stan1, plotfun = "hist", nreps = 5)
pp_check(post4, plotfun = "stat", stat = "mean")
pp_check(stan1, plotfun = "stat", stat = "mean")
pp_check(stan1, plotfun = "stat_2d", stat = c("mean", "sd"))
pp_check
pred_df
?posterior_predict
yrep <- posterior_predict(stan1)
head(yrep)
str(yrep)
apply(yrep, 2, quantile, probs = c(0.1, 0.5, 0.9))
yrep_summary <- t(apply(yrep, 2, quantile, probs = c(0.1, 0.5, 0.9)))
yrep_summary
statDat2 <- cbind(statDat, yrep_summary)
statDat2
head(statDat2)
statDat2 %>%
ggplot(aes(size_log, '50%', color = era)) +
geom_point() +
facet_wrap(~ group_j)
glimpse(statDat2)
statDat2 %>%
ggplot(aes(size_log, `50%``, color = era)) +
geom_point() +
facet_wrap(~ group_j)
statDat2 %>%
ggplot(aes(size_log, `50%`, color = era)) +
geom_point() +
facet_wrap(~ group_j)
statDat2 %>%
ggplot(aes(size_log, `50%`, color = era)) +
geom_point() +
facet_wrap(~ group_j) +
geom_abline(slope = 1, intercept = 0)
pp_check(stan1, plotfun = "hist", nreps = 5)
pp_check(stan1, plotfun = "stat", stat = "mean")
pp_check
?ppc_stat
ppc_stat(y = statDat$size_log, yrep = yrep, stat = "mean")
library(bayesplot)
ppc_stat(y = statDat$size_log, yrep = yrep, stat = "mean")
summary(stan1)
plot(stan1)
stan1
stan1
CORES <- 4
SEED <- 101
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat,
cores = CORES, seed = SEED)
pairs(stan1)
?stan_lmer
stan1 <- stan_lmer(size_log ~ era01 + (1 | group_j), data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.99)
stan1
summary(stan1)
plot(stan1)
pp_check(stan1, plotfun = "hist", nreps = 5)
pp_check(stan1, plotfun = "stat", stat = "mean")
pp_check(stan1, plotfun = "stat_2d", stat = c("mean", "sd"))
str(yrep)
stan1
## What I would like is the proportional change in size
stan1
list_of_draws <- extract(fit)
list_of_draws <- extract(stan1)
library(rstan)
list_of_draws <- extract(stan1)
list_of_draws <- rstan::extract(stan1)
class(stan1)
pars(stan1)
draws_era <- as.data.frame(fit2, pars = "era01")
draws_era <- as.data.frame(stan1, pars = "era01")
hist(draws_era)
head(draws_era)
str(draws_era)
hist(x = draws_era$era01)
draws_int <- as.data.frame(stan1, pars = "(Intercept)")
draws_int
head(draws_int)
## What I would like is the proportional change in size
stan1
summary(stan1)
draws_sigma <- as.data.frame(stan1, pars = "sigma")
draws_sigma
draws_era <- as.array(stan1, pars = "era01")
head(draws_era)
hist(draws_era)
str(draws_era)
draws_era <- as.matrix(stan1, pars = "era01")
draws_era <- as.matrix(stan1, pars = "era01")
hist(x = draws_era)
## Extract draws
draws_era <- as.matrix(stan1, pars = "era01")
draws_int <- as.matrix(stan1, pars = "(Intercept)")
draws_sigma <- as.matrix(stan1, pars = "sigma")
pred_size_past <- exp(draws_int)
pred_size_past <- 10^(draws_int)
pred_size_present <- pred_size_past - (10^(draws_era))
pred_proportion <- pred_size_present/pred_size_past
hist(pred_proportion)
pred_proportion <- (pred_size_present - pred_size_past)/pred_size_past
hist(pred_proportion)
boxplot(pred_proportion)
qplot(x = pred_proportion)
pred_proportion
?qplot
qplot(x = pred_proportion, geom = "boxplot")
str(pred_proportion)
qplot(x = pred_proportion[1], geom = "boxplot")
qplot(x = 1, y = pred_proportion[1], geom = "boxplot")
qplot(x = 1, y = pred_proportion[1, ], geom = "boxplot")
pred_proportion
str(pred_proportion)
pred_proportion <- as.vector((pred_size_present - pred_size_past)/pred_size_past)
str(pred_proportion)
qplot(x = 1, y = pred_proportion[1, ], geom = "boxplot")
qplot(x = 1, y = pred_proportion, geom = "boxplot")
qplot(x = 1, y = pred_proportion, geom = "boxplot") +
geom_hline(yintercept = 0, linetype = "dashed")
sjp.lmer(lmer1, type = "re", p.kr = F)
sjp.lmer(lmer1, type = "fe", p.kr = F)
summary(stan1)
stan1 <- stan_lm(size_log ~ era01, data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.95)
CORES <- 4
SEED <- 101
stan1 <- stan_lm(size_log ~ era01, data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.95)
?stan_lm
stan0_lm <- stan_lm(size_log ~ era01, data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.95)
stan0_lm <- stan_lm(size_log ~ era, data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.95)
##' Pooled model
lm1 <- lm(size_log ~ era01, data = statDat)
summary(lm1)
plot(lm1)
##' Partially pooled model (with random intercept for each group)
lmer2 <- lmer(size_log ~ era01 + (era01 | group_j), data = statDat)
summary(lmer2)
sjp.lmer(lmer1, type = "re", p.kr = F)
sjp.lmer(lmer1, type = "fe", p.kr = F)
stan1
## Pooled model
stan0 <- stan_lm(size_log ~ era01, data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.95)
## Pooled model
stan0 <- stan_lm(size_log ~ era01, data = statDat,
prior = R2(0.5),
cores = CORES, seed = SEED, adapt_delta = 0.95)
## Pooled model
stan0 <- stan_lm(size_log ~ era01, data = statDat,
prior = R2(0.5, what = "median"),
cores = CORES, seed = SEED)
plot(stan0)
pp_check(stan0, plotfun = "hist", nreps = 5)
pp_check(stan1, plotfun = "stat_2d", stat = c("mean", "sd"))
pp_check(stan0, plotfun = "stat_2d", stat = c("mean", "sd"))
class(stan0)
## A function to calculate proportional change using a stanreg object
get_prop_change <- function(stanreg_object){
## Extract draws
draws_era <- as.matrix(stanreg_object, pars = "era01")
draws_int <- as.matrix(stanreg_object, pars = "(Intercept)")
draws_sigma <- as.matrix(stanreg_object, pars = "sigma")
pred_size_past <- 10^(draws_int) # back-transform
pred_size_present <- pred_size_past - (10^(draws_era))
pred_change <- as.vector((pred_size_present - pred_size_past)/pred_size_past)
return(pred_change)
}
pred_change0 <- get_prop_change(stan0)
pred_change0
hist(pred_change0)
pred_change1 <- get_prop_change(stan1)
## Group-level intercepts and slopes
stan2 <- stan_lmer(size_log ~ era01 + (era01 | group_j), data = statDat,
cores = CORES, seed = SEED, adapt_delta = 0.99)
plot(stan2)
pred_change2 <- get_prop_change(stan2)
## Combine pred_change
pred_df <- data.frame(pred_change0, pred_change1, pred_change2)
pred_df
head(pred_df)
pred_long <- gather(pred_df)
pred_long
head(pred_long)
pred_long %>%
ggplot(aes(key, value)) +
geom_boxplot()
library(broom)
pred_long_quantiles <- pred_long %>%
group_by(key) %>%
do(tidy(t(quantile(.$value))))
pred_long_quantiles
pred_long_quantiles
pred_long_quantiles <- pred_long %>%
group_by(key) %>%
do(tidy(t(quantile(.$value)))) %>%
ungroup()
pred_long_quantiles
pred_long_quantiles <- pred_long %>%
group_by(key) %>%
do(tidy(t(quantile(.$value, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))))) %>%
ungroup()
pred_long_quantiles
?geom_errorbar
pred_long_quantiles %>%
ggplot(aes(key, X50.)) +
geom_point() +
geom_errorbar(aes(ymin = Xd2.5., ymax = X97.5.))
pred_long_quantiles %>%
ggplot(aes(key, X50.)) +
geom_point() +
geom_errorbar(aes(ymin = X2.5., ymax = X97.5.))
pred_long_quantiles %>%
ggplot(aes(key, X50.)) +
geom_point() +
geom_errorbar(aes(ymin = X2.5., ymax = X97.5.)) +
geom_hline(yintercept = 0, linetype = "dashed")
pred_long
pred_long <- gather(pred_df) %>% mutate(value = value * 100)
head(pred_long)
library(broom)
pred_long_quantiles <- pred_long %>%
group_by(key) %>%
do(tidy(t(quantile(.$value, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))))) %>%
ungroup()
pred_long_quantiles %>%
ggplot(aes(key, X50.)) +
geom_point() +
geom_errorbar(aes(ymin = X2.5., ymax = X97.5.)) +
geom_hline(yintercept = 0, linetype = "dashed")
?loo
## Compare model performance
library(loo)
log_lik0 <- extract_log_lik(stan0)
## Compare model performance
loo_0 <- loo_predict(stan0)
loo_0
