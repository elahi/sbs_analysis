# Chlorostoma funebralis = nest1 (Wara.B, Wara.D)
dat %>% filter(sp == "CHFU") %>% distinct(nest1)
### So, in these models, the sampling areas will be referred
# to as nest1 (random effect)
unique(dat$nest1)
##### Create list of 'sites' (i.e., logger positions)
# for Luke to run 15 yr hindcasts
### Logger positions are as follows:
head(dat)
unique(dat$position)
positionDF <- dat %>% group_by(position) %>% distinct()
unique(positionDF$position)
write.csv(positionDF, "./output/positionDF.csv")
# Create new column called 'sampleArea' based on
# the areas that were resampled in modern surveys
# This will be a random effect
# (rename nest1 to sampleArea)
dat$sampleArea <- dat$nest1
unique(dat$sampleArea)
head(dat)
glimpse(dat)
head(dat)
mod1 <- lmer(mean_tempC ~ sp + tidalHT + aspect + slope +
(1 | sampleArea) + (1 | position),
data = dat)
summary(mod1)
mod2 <- lmer(mean_tempC ~ sp +
(1 | sampleArea) + (1 | position),
data = dat)
summary(mod2)
anova(mod2)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
data = dat)
round(summary(lmeMod1)$tTable, 3)
anova(lmeMod1)
plot(lmeMod1)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corAR1(),
data = dat)
round(summary(lmeMod1)$tTable, 3)
anova(lmeMod1)
plot(lmeMod1)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
round(summary(lmeMod1)$tTable, 3)
anova(lmeMod1)
plot(lmeMod1)
summary(lmeMod1)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ position | sampleArea),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | position/sampleArea),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea/position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp,
random = list(~ position | sampleArea),
na.action = na.omit,
correlation = corAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp,
random = list(~ position | sp),
na.action = na.omit,
correlation = corAR1(),
data = dat)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
AIC(lmeMod1, lmeMod2)
?lme
statDat <- dat
library(AICcmodavg)
unique(lmeDat$sp)
statDat <- dat
unique(statDat$sp)
statDat$sp <- relevel(statDat$sp, ref = "LIKE")
str(statDat)
statDat$sp <- as.factor(statDat$sp)
dat$sp <- as.factor(statDat$sp)
dat$sp <- relevel(dat$sp, ref = "LIKE")
dat$sp <- as.factor(dat$sp)
# relevel species
dat$sp <- relevel(dat$sp, ref = "LIKE")
dat$sp <- as.factor(dat$sp)
str(dat)
# Set working directory to main project folder
setwd("~/github/sbs_analysis")
library(ggplot2)
theme_set(theme_classic(base_size = 8))
library(dplyr)
library(nlme)
source("./R/multiplotF.R")
###############################
# Load daily temperature data summarized by species
dat <- read.csv("./output/temp_daily_species.csv", header = TRUE)
head(dat)
dat$day <- as.Date(dat$day)
str(dat)
unique(dat$code)
dat$code <- relevel(dat$code, ref = "LIKE")
unique(dat$code)
# Figure out how many daily records per species,
# and mean tidal height
dat %>% group_by(code) %>% summarise(totalN = n(),
meanHT = mean(tidalHT, na.rm = TRUE),
sdHT = sd(tidalHT, na.rm = TRUE))
dat %>% group_by(code) %>% dplyr::summarise(totalN = n(),
meanHT = mean(tidalHT, na.rm = TRUE),
sdHT = sd(tidalHT, na.rm = TRUE))
# Get mean tidal heights for each of nested samples
dat %>% group_by(code, nest2) %>%
summarise(totalN = n(),
meanHT = mean(tidalHT, na.rm = TRUE),
sdHT = sd(tidalHT, na.rm = TRUE))
# Figure out how many daily records per species,
# and mean tidal height
dat %>% group_by(code) %>% dplyr::summarise(totalN = n(),
meanHT = mean(tidalHT, na.rm = TRUE),
sdHT = sd(tidalHT, na.rm = TRUE))
# Get mean tidal heights for each of nested samples
dat %>% group_by(code, nest2) %>%
dplyr::summarise(totalN = n(),
meanHT = mean(tidalHT, na.rm = TRUE),
sdHT = sd(tidalHT, na.rm = TRUE))
###############################################################
### Mixed-model analysis of temperature differences by species
###############################################################
###############################
### Set up model structure
# Fixed effects: species, tidalHT, aspect, slope
# Random intercepts: sampling area, logger position
# Random slopes: ?
# Each measurement is an observation
# Need autocorrelation (nlme)
head(dat)
# Need to define 'sampling areas' for each species,
# that were sampled in historic and modern studies
# Rename code to sp (for consistency)
dat <- dat %>% dplyr::rename(sp = code)
# Littorina keenae = nest1 (zoneA, zoneB, zoneC, zoneD)
dat %>% filter(sp == "LIKE") %>% distinct(nest1)
# Lottia digitalis = nest1 (1, 2, 3)
dat %>% filter(sp == "LODI") %>% distinct(nest1)
# Chlorostoma funebralis = nest1 (Wara.B, Wara.D)
dat %>% filter(sp == "CHFU") %>% distinct(nest1)
### So, in these models, the sampling areas will be referred
# to as nest1 (random effect)
unique(dat$nest1)
##### Create list of 'sites' (i.e., logger positions)
# for Luke to run 15 yr hindcasts
### Logger positions are as follows:
head(dat)
unique(dat$position)
positionDF <- dat %>% group_by(position) %>% distinct()
unique(positionDF$position)
write.csv(positionDF, "./output/positionDF.csv")
# Create new column called 'sampleArea' based on
# the areas that were resampled in modern surveys
# This will be a random effect
# (rename nest1 to sampleArea)
dat$sampleArea <- dat$nest1
unique(dat$sampleArea)
head(dat)
glimpse(dat)
statDat <- dat
unique(statDat$sp)
mod1 <- lmer(mean_tempC ~ sp + tidalHT + aspect + slope +
(1 | sampleArea) + (1 | position),
data = statDat)
summary(mod1)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
lmeMod2 <- lme(fixed = mean_tempC ~ sp + tidalHT + aspect + slope,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
AIC(lmeMod1, lmeMod2)
summary(lmeMod2)
summary(lmeMod2)$tTable
round(summary(lmeMod2)$tTable, 3)
round(summary(lmeMod1)$tTable, 3)
lmeMod2 <- lme(fixed = mean_tempC ~ sp + tidalHT + aspect + slope,
random = list(~ 1 | sampleArea),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
summary(lmeMod2)
lmeMod2 <- lme(fixed = mean_tempC ~ sp + tidalHT +  slope,
random = list(~ 1 | sampleArea),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
summary(lmeMod2)
unique(statDat$nest2)
lmeMod1 <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit,
correlation = corCAR1(),
data = dat)
round(summary(lmeMod1)$tTable, 3)
summary(lmeMod2)
Cand.mod <- list()
# final full model
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp + tidalHT + slope,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
# final full model
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp + tidalHT + slope,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[3]] <- lme(fixed = mean_tempC ~ tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[4]] <- lme(fixed = mean_tempC ~ 1,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Era x Species", "Era + Species", "Era",
"Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp * tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- lme(fixed = mean_tempC ~ sp + tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[3]] <- lme(fixed = mean_tempC ~ tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[4]] <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[5]] <- lme(fixed = mean_tempC ~ 1,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Era x Species", "Era + Species", "Era",
"Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
Cand.mod <- list()
# final full model
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp + tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- lme(fixed = mean_tempC ~ tidalHT,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[3]] <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[4]] <- lme(fixed = mean_tempC ~ 1,
random = list(~ 1 | sampleArea),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Era x Species", "Era + Species", "Era",
"Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp)) +
geom_point()
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp)) +
geom_point() + geom_violin()
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp)) +
geom_point(alpha = 0.5)
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp, shape = sp)) +
geom_point(alpha = 0.5)
rawDat <- read.csv("./output/temp_raw_iButton.csv", header = TRUE)
str(rawDat)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.5)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.1)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.1, size = 0.1)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.1, size = 0.5)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.1, size = 1)
ggplot(data = rawDat, aes(tidalHT, tempC, color = code, shape = code)) +
geom_point(alpha = 0.1, size = 2)
unique(statDat$nest2)
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp, shape = sp)) +
geom_point(alpha = 0.5)
ggplot(data = statDat, aes(tidalHT, min_tempC, color = sp, shape = sp)) +
geom_point(alpha = 0.5)
ggplot(data = statDat, aes(tidalHT, max_tempC, color = sp, shape = sp)) +
geom_point(alpha = 0.5)
summary(Cand.mod[[2]])
Cand.mod[[2]] <- update(Cand.mod[[1]], - sp)
Cand.mod[[2]] <- update(Cand.mod[[1]], ~. - sp)
summary(Cand.mod[[2]])
Cand.mod[[3]] <- update(Cand.mod[[1]], ~. - tidalHT)
Cand.mod[[4]] <- update(Cand.mod[[1]], ~. - tidalHT - sp)
summary(Cand.mod[[4]])
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Species + Tidal Height", "Species", "Tidal height",
"Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
mod_text <- c("Species + Tidal Height", "Tidal height", "Species",
"Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
# Format the data frame for nicer printing
aic_table <- data.frame(cbind(data.frame(mod.aicctab)[1],
round(data.frame(mod.aicctab)[2:8], 3)))
write.csv(aic_table, "./output/temp_AIC.csv")
bestMod <- update(Cand.mod[[2]], REML = TRUE)
bestMod <- update(Cand.mod[[2]], method = "REML")
summary(bestMod)
plot(bestMod)
summaryStats <- statDat %>% group_by(species, sp) %>%
summarise(meanTemp = mean(mean_tempC, na.rm = TRUE),
sdTemp = sd(mean_tempC, na.rm = TRUE),
minTemp = min(min_tempC,  na.rm = TRUE),
maxTemp = max(max_tempC, na.rm = TRUE))
summaryStats <- statDat %>% group_by(sp) %>%
summarise(meanTemp = mean(mean_tempC, na.rm = TRUE),
sdTemp = sd(mean_tempC, na.rm = TRUE),
minTemp = min(min_tempC,  na.rm = TRUE),
maxTemp = max(max_tempC, na.rm = TRUE))
summaryStats
head(statDat)
summaryStats <- statDat %>% group_by(sp) %>%
summarise(meanTemp = mean(mean_tempC, na.rm = TRUE),
sdTemp = sd(mean_tempC, na.rm = TRUE),
minTemp = min(min_tempC,  na.rm = TRUE),
maxTemp = max(max_tempC, na.rm = TRUE))
summaryStats
plot(lmeMod1)
fullMod <- update(Cand.mod[[1]], method = "REML")
summary(fullMod)
plot(fullMod)
ggplot(data = statDat, aes(tidalHT, mean_tempC, color = sp, shape = sp)) +
geom_point(alpha = 0.5)
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- update(Cand.mod[[1]], ~. - sp)
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Species + Tidal Height", "Tidal height", "Species",
"Null model")
mod_text <- c("Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
Cand.mod <- list()
# final full model
Cand.mod[[1]] <- lme(fixed = mean_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- update(Cand.mod[[1]], ~. - sp)
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Species", "Null model")
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
# Format the data frame for nicer printing
aic_table <- data.frame(cbind(data.frame(mod.aicctab)[1],
round(data.frame(mod.aicctab)[2:8], 3)))
write.csv(aic_table, "./output/temp_mean_AIC.csv")
fullMod <- update(Cand.mod[[1]], method = "REML")
summary(fullMod)
plot(fullMod)
anova(Cand.mod[[1]], Cand.mod[[2]])
Cand.mod[[1]] <- lme(fixed = max_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- update(Cand.mod[[1]], ~. - sp)
anova(Cand.mod[[1]], Cand.mod[[2]])
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
# Format the data frame for nicer printing
aic_table <- data.frame(cbind(data.frame(mod.aicctab)[1],
round(data.frame(mod.aicctab)[2:8], 3)))
write.csv(aic_table, "./output/temp_max_AIC.csv")
plot(Cand.mod[[1]])
Cand.mod <- list()
# final full model
Cand.mod[[1]] <- lme(fixed = min_tempC ~ sp,
random = list(~ 1 | sampleArea, ~ 1 | position),
na.action = na.omit, method = "ML",
correlation = corCAR1(),
data = dat)
Cand.mod[[2]] <- update(Cand.mod[[1]], ~. - sp)
anova(Cand.mod[[1]], Cand.mod[[2]])
#create a vector of names to trace back models in set
mod_numbers <- paste("Cand.mod", 1:length(Cand.mod), sep=" ")
mod_text <- c("Species", "Null model")
#generate AICc table with numbers
mod.aicctab <- aictab(cand.set= Cand.mod, modnames=mod_numbers, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
#generate AICc table with names
mod.aicctab <- aictab(cand.set= Cand.mod, modnames= mod_text, sort=TRUE,
second.ord=FALSE) # second.ord =TRUE means AICc is used (not AIC)
print(mod.aicctab, digits=2, LL=TRUE)
# Format the data frame for nicer printing
aic_table <- data.frame(cbind(data.frame(mod.aicctab)[1],
round(data.frame(mod.aicctab)[2:8], 3)))
write.csv(aic_table, "./output/temp_min_AIC.csv")
plot(Cand.mod[[1]])
Cand.mod[[1]]
?citation
x <- citation()
toBibtex(x)
