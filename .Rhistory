# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
##### ESTIMATE PROPORTIONAL CHANGE #####
b1 <- summary(zm)$stat[1]
b2 <- summary(zm)$stat[2]
past_size <- 10^b1
present_size <- 10^(b1+b2)
prop_change <- (present_size - past_size)/past_size
## Using jags samples
zj_b0 <- zj$beta0
zj_b1 <- zj$beta1
past_size <- 10^zj_b0
present_size <- 10^(zj_b0 + zj_b1)
prop_change <- (present_size - past_size)/past_size
str(prop_change)
summary(prop_change, quantile, c(0.025, 0.5, 0.975))$stat
##### FIGURES #####
# Credible intervals
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
# Prediction intervals
y_new <- summary(zj$y_new, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median_pred <- y_new[2, ]
pred_df$y_lower_pred <- y_new[1, ]
pred_df$y_upper_pred <- y_new[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
statDat$dens_stand <- dens_cent/dens_sd
statDat$tideHTm_stand <- as.numeric(scale(statDat$tideHTm))
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
x_predict_stand <- (x_predict - dens_mu)/dens_sd
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
pred_df$tideHTm_stand <- statDat$tideHTm_stand
# For plotting predicted values - tidal height
x2_min <- min(statDat$tideHTm)
x2_max <- max(statDat$tideHTm)
x2_min
x2_predict <- seq(x2_min, x2_max, length.out = 100)
x2_predict
x2_predict_stand <- as.numeric(scale(x2_predict))
x2_predict_stand
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
pred_df$x2_predict <- x2_predict_stand
pred_df$x_predict0 <- 0 # predict at average density
pred_df$x2_predict0 <- 0 # predict at average tidal height
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df() %>%
mutate(x_predict = x_predict,
x2_predict = x2_predict_stand)
# Choose data to models
statDat <- dens_childs %>% filter(!is.na(dens_log) & !is.na(mass_log))
# Get era as 0 or 1
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
statDat$dens_stand <- dens_cent/dens_sd
statDat$tideHTm_stand <- as.numeric(scale(statDat$tideHTm))
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
x_predict_stand <- (x_predict - dens_mu)/dens_sd
# For plotting predicted values - tidal height
x2_min <- min(statDat$tideHTm)
x2_max <- max(statDat$tideHTm)
x2_predict <- seq(x2_min, x2_max, length.out = 100)
x2_predict_stand <- as.numeric(scale(x2_predict))
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df() %>%
mutate(x_predict = x_predict,
x2_predict = x2_predict_stand)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
pred_df$x2_predict <- x2_predict_stand
pred_df
pred_df$x_predict0 <- 0 # predict at average density
pred_df$x2_predict0 <- 0 # predict at average tidal height
pred_df
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size_log),
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
tideHTm = as.double(statDat$tideHTm_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict),
tide_predict = as.double(pred_df$tideHTm_stand)
)
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size_log),
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
tideHTm = as.double(statDat$tideHTm_stand),
era_predict = as.double(pred_df$era_predict),
x_predict = as.double(pred_df$x_predict_stand),
tide_predict = as.double(pred_df$x2_predict_stand),
x_predict0 = as.double(pred_df$x_predict0),
tide_predict0 = as.double(pred_df$x2_predict0)
)
pred_df$x2_predict_stand <- x2_predict_stand
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size_log),
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
tideHTm = as.double(statDat$tideHTm_stand),
era_predict = as.double(pred_df$era_predict),
x_predict = as.double(pred_df$x_predict_stand),
tide_predict = as.double(pred_df$x2_predict_stand),
x_predict0 = as.double(pred_df$x_predict0),
tide_predict0 = as.double(pred_df$x2_predict0)
)
inits = list(
#list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
#list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
#list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10),
list(beta0 = 0, beta1 = -0.1, beta2 = 0.4, beta3 = -4, beta4 = 0, beta5 = -0.5, sigma = 4))
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model_logsize_density_era_tide.R",
data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"beta4", "beta5","sigma"),
n.iter = n.iter, n.thin = 10)
zj = jags.samples(jm, variable.names = c("y_pred_tide0", "y_pred_dens0", "beta0", "beta1",
"p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 10)
#Produce a summary table for the parameters.
summary(zm)
10^(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
densplot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
##### ESTIMATE PROPORTIONAL CHANGE #####
b1 <- summary(zm)$stat[1]
b2 <- summary(zm)$stat[2]
past_size <- 10^b1
present_size <- 10^(b1+b2)
prop_change <- (present_size - past_size)/past_size
zj_b0 <- zj$beta0
zj_b1 <- zj$beta1
past_size <- 10^zj_b0
present_size <- 10^(zj_b0 + zj_b1)
prop_change <- (present_size - past_size)/past_size
str(prop_change)
summary(prop_change, quantile, c(0.025, 0.5, 0.975))$stat
# Credible intervals
y_predict <- summary(zj$y_pred_dens0, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
# Credible intervals
y_predict <- summary(zj$y_pred_tide0, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
# geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
#             alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
# Credible intervals
y_predict <- summary(zj$y_pred_dens0, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x2_predict, y_median))
pred_df %>%
ggplot(aes(x2_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
# geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
#             alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
pred_df %>%
ggplot(aes(x2_predict, y_median, color = era)) +
geom_line()
pred_df$x2_predict <- x2_predict
pred_df %>%
ggplot(aes(x2_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
# geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
#             alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
pred_df %>%
ggplot(aes(x2_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
# geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
#             alpha = 0.25) +
geom_point(data = statDat, aes(tideHTm, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
# Credible intervals
y_predict <- summary(zj$y_pred_tide0, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
# geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
#             alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
rm(list=ls(all=TRUE))
library(broom)
library(ggplot2)
library(cowplot)
# Load data
source("2_summarise_data/summarise_size_density.R")
source("R/HighstatLibV6.R")
statDat <- dat_dens
# Subset data by species
dens_wara <- statDat %>% filter(sp == "CHFU")
dens_hex <- statDat %>% filter(sp == "LODI")
dens_childs <- statDat %>% filter(sp == "LIKE")
dens_wara %>% select(density_m2, tideHTm) %>% Mypairs()
dens_hex %>% select(density_m2, tideHTm) %>% Mypairs()
dens_childs %>% select(density_m2, tideHTm) %>% Mypairs()
##### PREPARE DATA FOR JAGS #####
library(rjags)
# Choose data to models
statDat <- dens_childs %>% filter(!is.na(dens_log) & !is.na(mass_log))
# Get era as 0 or 1
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
statDat$dens_stand <- dens_cent/dens_sd
statDat$tideHTm_stand <- as.numeric(scale(statDat$tideHTm))
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
x_predict_stand <- (x_predict - dens_mu)/dens_sd
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size_log),
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict)
)
inits = list(
#list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
#list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10),
list(beta0 = 0, beta1 = -0.1, beta2 = 0.4, beta3 = -4, sigma = 4))
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model_logsize_density_era.R",
data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model_logsize_density.R",
data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3","sigma"),
n.iter = n.iter, n.thin = 10)
zj = jags.samples(jm, variable.names = c("y_pred", "y_new", "beta0", "beta1",
"p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 10)
#Produce a summary table for the parameters.
summary(zm)
10^(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
densplot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
##### ESTIMATE PROPORTIONAL CHANGE #####
b1 <- summary(zm)$stat[1]
b2 <- summary(zm)$stat[2]
past_size <- 10^b1
present_size <- 10^(b1+b2)
prop_change <- (present_size - past_size)/past_size
zj_b0 <- zj$beta0
zj_b1 <- zj$beta1
past_size <- 10^zj_b0
present_size <- 10^(zj_b0 + zj_b1)
prop_change <- (present_size - past_size)/past_size
str(prop_change)
summary(prop_change, quantile, c(0.025, 0.5, 0.975))$stat
# Credible intervals
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
# Prediction intervals
y_new <- summary(zj$y_new, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median_pred <- y_new[2, ]
pred_df$y_lower_pred <- y_new[1, ]
pred_df$y_upper_pred <- y_new[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
# statDat <- dens_wara %>% filter(!is.na(dens_log) & !is.na(mass_log))
statDat <- dens_hex %>% filter(!is.na(dens_log) & !is.na(mass_log))
# Get era as 0 or 1
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
statDat$dens_stand <- dens_cent/dens_sd
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
x_predict_stand <- (x_predict - dens_mu)/dens_sd
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size_log),
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict)
)
##### QUANTILE: ERA X DENSITY####
inits = list(
#list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
#list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10),
list(beta0 = 0, beta1 = -0.1, beta2 = 0.4, beta3 = -4, sigma = 4))
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model_logsize_density.R",
data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3","sigma"),
n.iter = n.iter, n.thin = 10)
zj = jags.samples(jm, variable.names = c("y_pred", "y_new", "beta0", "beta1",
"p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 10)
#Produce a summary table for the parameters.
summary(zm)
10^(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
densplot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
##### ESTIMATE PROPORTIONAL CHANGE #####
b1 <- summary(zm)$stat[1]
b2 <- summary(zm)$stat[2]
past_size <- 10^b1
present_size <- 10^(b1+b2)
prop_change <- (present_size - past_size)/past_size
## Using jags samples
zj_b0 <- zj$beta0
zj_b1 <- zj$beta1
past_size <- 10^zj_b0
present_size <- 10^(zj_b0 + zj_b1)
prop_change <- (present_size - past_size)/past_size
str(prop_change)
summary(prop_change, quantile, c(0.025, 0.5, 0.975))$stat
##### FIGURES #####
# Credible intervals
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
# Prediction intervals
y_new <- summary(zj$y_new, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median_pred <- y_new[2, ]
pred_df$y_lower_pred <- y_new[1, ]
pred_df$y_upper_pred <- y_new[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
with(pred_df, plot(x_predict, y_median))
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
geom_ribbon(aes(ymin = y_lower_pred, ymax = y_upper_pred, fill = era, color = NULL),
alpha = 0.25) +
geom_point(data = statDat, aes(density_m2, size_log, color = era), alpha = 0.5) +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
