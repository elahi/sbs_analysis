#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
#Produce a summary table for the parameters.
summary(zm)
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = 1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2))
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2))
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
rm(list=ls(all=TRUE))
library(broom)
library(ggplot2)
library(cowplot)
# Load data
source("2_summarise_data/summarise_size_density.R")
statDat <- dat_dens
dens_childs <- statDat %>% filter(sp == "LIKE")
# Subset data by species
dens_wara <- statDat %>% filter(sp == "CHFU")
dens_hex <- statDat %>% filter(sp == "LODI")
dens_childs <- statDat %>% filter(sp == "LIKE")
##### PREPARE DATA FOR JAGS #####
library(rjags)
statDat <- dens_childs %>% filter(!is.na(dens_log) & !is.na(mass_log))
statDat <- dens_childs %>% filter(!is.na(dens_log) & !is.na(mass_log))
# Get era as 0 or 1
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict, era_predict) %>%
rename(x_predict = Var1, era_predict = Var2) %>% tbl_df()
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size1mm), # number of oasis detections
era = as.double(statDat$era01),
x = as.double(statDat$density_m2),
x_predict = as.double(pred_df$x_predict),
era_predict = as.double(pred_df$era_predict)
)
# JAGS model
sink("3_analyse_data/bayes_models/model2.R")
cat("
model{
# priors
beta0 ~ dnorm(0, 1/10^2)
beta1 ~ dnorm(0, 1/10^2)
beta2 ~ dnorm(0, 1/10^2)
beta3 ~ dnorm(0, 1/10^2)
sigma ~ dunif(0, 10)
tau <- 1/sigma^2
# likelihood
for (i in 1:N){
mu[i] <- exp(beta0 + beta1*era[i] + beta2*x[i] + beta3*era[i]*x[i])
y[i] ~ dlnorm(log(mu[i]), tau)
y.new[i] ~ dlnorm(log(mu[i]), tau)
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
# bayesian p-values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(x_predict)){
y_pred[j] <- exp(beta0 + beta1*era_predict[j] + beta2*x_predict[j] + beta3*era_predict[j]*x_predict[j])
}
}
", fill = TRUE)
sink()
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2))
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("y_pred", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10))
# Number of iterations
n.adapt <- 2000
n.update <- 2000
n.iter <- 2000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("y_pred", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
# Plot prediction
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
#geom_point(data = statDat, aes(density_m2, size1mm, color = era), alpha = 0.5) +
geom_boxplot(data = statDat, aes(density_m2, size1mm, group = density_m2)) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10),
list(beta0 = 0, beta1 = -0.1, beta2 = 0.4, beta3 = -4, sigma = 4))
# Number of iterations
n.adapt <- 5000
n.update <- 5000
n.iter <- 5000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("y_pred", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
#Produce a summary table for the p
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
# Center and standardize
dens_mu <- mean(statDat$density_m2)
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
dens_stand <- dens_cent/dens_sd
dens_stand
x_predict_stand <- (x_predict - dens_mu)/dens_sd
x_predict_stand
# For prediction
era_predict <- c(0,1)
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict = Var1, era_predict = Var2) %>% tbl_df()
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size1mm), # number of oasis detections
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict)
)
statDat$dens_stand <- dens_cent/dens_sd
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size1mm), # number of oasis detections
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict)
)
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size1mm), # number of oasis detections
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict),
era_predict = as.double(pred_df$era_predict)
)
# JAGS model
sink("3_analyse_data/bayes_models/model2.R")
cat("
model{
# priors
beta0 ~ dnorm(0, 1/10^2)
beta1 ~ dnorm(0, 1/10^2)
beta2 ~ dnorm(0, 1/10^2)
beta3 ~ dnorm(0, 1/10^2)
sigma ~ dunif(0, 10)
tau <- 1/sigma^2
# likelihood
for (i in 1:N){
mu[i] <- exp(beta0 + beta1*era[i] + beta2*x[i] + beta3*era[i]*x[i])
y[i] ~ dlnorm(log(mu[i]), tau)
y.new[i] ~ dlnorm(log(mu[i]), tau)
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
# bayesian p-values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(x_predict)){
y_pred[j] <- exp(beta0 + beta1*era_predict[j] + beta2*x_predict[j] + beta3*era_predict[j]*x_predict[j])
}
}
", fill = TRUE)
sink()
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"sigma"),
n.iter = n.iter, n.thin = 10)
zj = jags.samples(jm, variable.names = c("y_pred", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 10)
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
# Plot prediction
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
#geom_point(data = statDat, aes(density_m2, size1mm, color = era), alpha = 0.5) +
geom_boxplot(data = statDat, aes(density_m2, size1mm, group = density_m2)) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
y_predict
pred_df
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5)
# statDat <- dens_wara %>% filter(!is.na(dens_log) & !is.na(mass_log))
statDat <- dens_hex %>% filter(!is.na(dens_log) & !is.na(mass_log))
# Get era as 0 or 1
statDat <- statDat %>% mutate(era01 = ifelse(era == "past", 0, 1))
# Center and standardize
dens_mu <- mean(statDat$density_m2)
dens_sd <- sd(statDat$density_m2)
dens_cent <- statDat$density_m2 - dens_mu
statDat$dens_stand <- dens_cent/dens_sd
# For plotting predicted values
x_min <- min(statDat$density_m2)
x_max <- max(statDat$density_m2)
x_predict <- seq(x_min, x_max, length.out = 100)
x_predict_stand <- (x_predict - dens_mu)/dens_sd
pred_df <- expand.grid(x_predict_stand, era_predict) %>%
rename(x_predict_stand = Var1, era_predict = Var2) %>% tbl_df()
pred_df$x_predict <- x_predict
# Get data
data = list(
N = nrow(statDat),
y = as.double(statDat$size1mm), # number of oasis detections
era = as.double(statDat$era01),
x = as.double(statDat$dens_stand),
x_predict = as.double(pred_df$x_predict_stand),
era_predict = as.double(pred_df$era_predict)
)
# JAGS model
sink("3_analyse_data/bayes_models/model2.R")
cat("
model{
# priors
beta0 ~ dnorm(0, 1/10^2)
beta1 ~ dnorm(0, 1/10^2)
beta2 ~ dnorm(0, 1/10^2)
beta3 ~ dnorm(0, 1/10^2)
sigma ~ dunif(0, 10)
tau <- 1/sigma^2
# likelihood
for (i in 1:N){
mu[i] <- exp(beta0 + beta1*era[i] + beta2*x[i] + beta3*era[i]*x[i])
y[i] ~ dlnorm(log(mu[i]), tau)
y.new[i] ~ dlnorm(log(mu[i]), tau)
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
# bayesian p-values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(x_predict)){
y_pred[j] <- exp(beta0 + beta1*era_predict[j] + beta2*x_predict[j] + beta3*era_predict[j]*x_predict[j])
}
}
", fill = TRUE)
sink()
inits = list(
list(beta0 = 1, beta1 = 0.5, beta2 = 0.1, beta3 = 1, sigma = 1),
list(beta0 = -1, beta1 = -0.5, beta2 = -0.1, beta3 = 0, sigma = 0.2),
list(beta0 = 2, beta1 = 0.1, beta2 = 0, beta3 = -0.01, sigma = 10),
list(beta0 = 0, beta1 = -0.1, beta2 = 0.4, beta3 = -4, sigma = 4))
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
## Run model
jm <- jags.model("3_analyse_data/bayes_models/model2.R", data = data,
inits = inits, n.chains = length(inits),
n.adapt = n.adapt)
update(jm, n.iter = n.update)
zm = coda.samples(jm, variable.names = c("beta0", "beta1", "beta2", "beta3",
"sigma"),
n.iter = n.iter, n.thin = 10)
zj = jags.samples(jm, variable.names = c("y_pred", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 10)
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # intercept
#Produce trace plots of the chains for model parameters.
plot(zm)
# Test for convergence using the Gelman diagnostic.
gelman.diag(zm, multivariate = F)
# Check Bayesian pvals
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
# Plot prediction
y_predict <- summary(zj$y_pred, quantile, c(0.025, 0.5, 0.975))$stat
pred_df$y_median <- y_predict[2, ]
pred_df$y_lower <- y_predict[1, ]
pred_df$y_upper <- y_predict[3, ]
pred_df$era <- ifelse(pred_df$era_predict == 0, "past", "present")
pred_df %>%
ggplot(aes(x_predict, y_median, color = era)) +
geom_line() +
geom_ribbon(aes(ymin = y_lower, ymax = y_upper, fill = era, color = NULL),
alpha = 0.5) +
#geom_point(data = statDat, aes(density_m2, size1mm, color = era), alpha = 0.5) +
geom_boxplot(data = statDat, aes(density_m2, size1mm, group = density_m2)) +
ggtitle("Bayesian model") +
theme(legend.position = c(0.01, 0.01), legend.justification = c(0.01, 0.01))
## Childs
statDat <- dens_childs
lm1 <- lm(mass_log ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
lm1 <- lm(mass_mg ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
lm1 <- lm(mass_log ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
## Hexter
statDat <- dens_hex
lm1 <- lm(mass_log ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
lm1 <- lm(log10(size1mm) ~ era*density_m2, data = statDat)
summary(lm1)
## Childs
statDat <- dens_childs
lm1 <- lm(log10(size1mm) ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
## Hexter
statDat <- dens_hex
lm1 <- lm(log10(size1mm) ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
## Wara
statDat <- dens_wara
lm1 <- lm(log10(size1mm) ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
?glm
glm1 <- glm(size1mm ~ era*density_m2, family = gaussian(link = "log"), data = statDat)
summary(glm1)
plot(glm1)
## Wara
statDat <- dens_wara
lm1 <- lm(log10(size1mm) ~ era*density_m2, data = statDat)
summary(lm1)
plot(lm1)
glm1 <- glm(size1mm ~ era*density_m2, family = gaussian(link = "log"), data = statDat)
summary(glm1)
plot(glm1)
## Wara
statDat <- dens_wara
glm1 <- glm(size1mm ~ era*density_m2, family = gaussian(link = "log"), data = statDat)
summary(glm1)
## Wara
statDat <- dens_wara %>% mutate(dens_stand = as.numeric(scale(density_m2)))
statDat
summary(statDat$dens_stand)
lm1 <- lm(log10(size1mm) ~ era*dens_stand, data = statDat)
summary(lm1)
plot(lm1)
glm1 <- glm(size1mm ~ era*density_m2, family = gaussian(link = "log"), data = statDat)
summary(glm1)
## Wara
statDat <- dens_wara %>% mutate(dens_stand = as.numeric(scale(density_m2)))
lm1 <- lm(log10(size1mm) ~ era*dens_stand, data = statDat)
summary(lm1)
glm1 <- glm(size1mm ~ era*dens_stand, family = gaussian(link = "log"), data = statDat)
summary(glm1)
?family
## Hexter
statDat <- dens_hex %>% mutate(dens_stand = as.numeric(scale(density_m2)))
lm1 <- lm(log10(size1mm) ~ era*dens_stand, data = statDat)
summary(lm1)
glm1 <- glm(size1mm ~ era*dens_stand, family = gaussian(link = "log"), data = statDat)
summary(glm1)
plot(glm1)
## Childs
statDat <- dens_childs %>% mutate(dens_stand = as.numeric(scale(density_m2)))
lm1 <- lm(log10(size1mm) ~ era*dens_stand, data = statDat)
summary(lm1)
glm1 <- glm(size1mm ~ era*dens_stand, family = gaussian(link = "log"), data = statDat)
summary(glm1)
