#y.new[i] ~ dlnorm(log(mu[i]) - 0.67*sigma, tau)
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
# bayesian p-values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(thc_predict)){
y_pred[j] <- exp(alpha + beta*era_predict[j] + eta*thc_predict[j] + kappa*thc_predict[j]*era_predict[j])
beta_pred[j] <- log(y_pred[j]) - alpha - eta*thc_predict[j]
}
}
", fill = TRUE)
sink()
jm = jags.model("sbs_bayes/models/model_jags.R", data = data, inits = inits,
n.chains = length(inits), n.adapt = n.adapt)
update(jm, n.iter = n.update)
return(jm)
}
## GAMMA DISTRIBUTION
model_jags <- function(dat, iter_adapt, iter_update, n_chains){
# load jags
library(rjags)
## Get data
data = list(
#y = as.double(dat$size1mm),
#y = as.double(log(dat$size1mm)),
y = as.double(dat$size_centered),
k = as.double(length(dat$size1mm)),
thc = as.double(dat$thc),
era = as.double(dat$eraJ),
thc_predict = as.double(pred_df$thc_predict),
era_predict = as.double(pred_df$era_predict)
)
## Iterations
n.adapt = iter_adapt
n.update = iter_update
## Inits
if(n_chains == 1){
inits = list(
alpha = runif(1, 0, 30),
beta = runif(1, -10, 10),
sigma = 1,
eta = 2,
kappa = 1)
}
if(n_chains == 2){
inits = list(
list(
alpha = runif(1, 0, 30),
beta = runif(1, -10, 10),
sigma = 1,
eta = 2,
kappa = 1),
list(
alpha = runif(1, 0, 30),
beta = runif(1, -10, 10),
sigma = 1,
eta = -1,
kappa = -3)
)
}
## JAGS model
sink("sbs_bayes/models/model_jags.R")
cat("
model{
# priors
alpha ~ dgamma(0.001, 0.001) # vague prior
beta ~ dnorm(0, 1/10^2)
sigma ~ dunif(0, 100)
tau <- 1/sigma^2
eta ~ dnorm(0, 1/10^2)
kappa ~ dnorm(0, 1/10^2)
# likelihood
for (i in 1:k){
mu[i] <- exp(alpha + beta*era[i] + eta*thc[i] + kappa*thc[i]*era[i])
# parameterized by mean (m) and standard deviation (sd)
sh[i] <- pow(mu[i],2) / pow(sigma,2)
ra[i] <-     mu[i]    / pow(sigma,2)
y[i] ~ dgamma(sh[i], ra[i])
y.new[i] ~ dgamma(sh[i], ra[i])
sq.error.data[i] <- (y[i] - mu[i])^2
sq.error.new[i] <- (y.new[i] - mu[i])^2
}
# bayesian p-values
sd.data <- sd(y)
sd.new <- sd(y.new)
p.sd <- step(sd.new - sd.data)
mean.data <- mean(y)
mean.new  <- mean(y.new)
p.mean <- step(mean.new - mean.data)
discrep.data <- sum(sq.error.data)
discrep.new <- sum(sq.error.new)
p.discrep <- step(discrep.new - discrep.data)
# Derived quantities
for(j in 1:length(thc_predict)){
y_pred[j] <- exp(alpha + beta*era_predict[j] + eta*thc_predict[j] + kappa*thc_predict[j]*era_predict[j])
beta_pred[j] <- log(y_pred[j]) - alpha - eta*thc_predict[j]
}
}
", fill = TRUE)
sink()
jm = jags.model("sbs_bayes/models/model_jags.R", data = data, inits = inits,
n.chains = length(inits), n.adapt = n.adapt)
update(jm, n.iter = n.update)
return(jm)
}
jm = model_jags(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep",
"y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
summary(zm)
exp(0.4)
dat %>% group_by(era) %>% summarise(median(size_centered))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
coda_summary <- summary(zm)
childs_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "LIKE",
param = rownames(coda_summary$quantile))
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size_centered, color = era), alpha = 0.5)
y <- summary(zj$beta_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(era == "present") %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray")
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size_centered, color = era), alpha = 0.5)
dat <- childsDF
my_quantile = 0.5
size0.5 <- dat %>% filter(era == "past") %>% summarise(size0.5 = quantile(size1mm, probs = my_quantile))
size0.5
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat <- childsDF
my_quantile = 0.5
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat$size0.5 <- size0.5
dat %>%
ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era) +
geom_vline(aes(xintercept = size0.25), color = "blue", linetype = "dashed") +
geom_vline(aes(xintercept = size0.5), color = "red", linetype = "dashed")
dat <- dat %>% filter(size1mm >= size0.5)
dat %>% count(sampleArea, era)
dat %>% count(era)
dat %>%
ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
truncate_data <- function(dat, quant = 0.5, subtract_value = 1){
my_quantile = quant
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat$size0.5 <- size0.5
dat <- dat %>% filter(size1mm >= size0.5)
# Need to subtract minimum size so that I can use a distribution appropriately
dat <- dat %>%
mutate(size_min = min(size1mm) - subtract_value,
size_centered = size1mm - size_min)
}
dat <- childsDF
truncate_data <- function(dat, quant = 0.5, subtract_value = 1){
my_quantile = quant
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat$size0.5 <- size0.5
dat <- dat %>% filter(size1mm >= size0.5)
# Need to subtract minimum size so that I can use a distribution appropriately
dat <- dat %>%
mutate(size_min = min(size1mm) - subtract_value,
size_centered = size1mm - size_min)
}
dat
dat <- truncate_data()
dat <- truncate_data(dat)
dat <- hexDF
dat %>%
ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
start_time <- proc.time()
jm = model_jags(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma", "eta", "kappa"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep",
"y_pred", "beta_pred"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
summary(zm)
exp(1.2)
dat %>% group_by(era) %>% summarise(median(size_centered))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size1mm, breaks = 20, freq=FALSE)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
coda_summary <- summary(zm)
hex_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "LODI",
param = rownames(coda_summary$quantile))
y <- summary(zj$y_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(th > 2 & th < 8) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size_centered, color = era), alpha = 0.5)
xy %>%
filter(th > 1 & th < 3) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size_centered, color = era), alpha = 0.5)
xy %>%
filter(th > 1.5 & th < 3) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_jitter(data = dat, aes(sample_area_tidal_ht, size_centered, color = era), alpha = 0.5)
y <- summary(zj$beta_pred, quantile, c(.025, .5, .975))$stat
y <- data.frame(t(y))
xy <- cbind(pred_df, y) %>%
mutate(era = ifelse(era_predict == 0, "past", "present"),
th = thc_predict + mu_th,
size_median = exp(X50.),
size_lower = exp(X2.5.),
size_upper = exp(X97.5.))
xy %>%
filter(era == "present") %>%
filter(th > 1.5 & th < 2.75) %>%
ggplot(aes(x = th, y = X50., color = era)) +
geom_line() +
geom_ribbon(aes(ymin = X2.5., ymax = X97.5., color = NULL, group = era),
fill = "gray", alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray")
source("sbs_bayes/model_pooled_truncated.R")
# Number of iterations
n.adapt <- 1000
n.update <- 1000
n.iter <- 1000
# Number of chains
n_chains <- 1
era_predict <- c(0,1)
pred_df <- expand.grid(thc_predict, era_predict) %>%
rename(thc_predict = Var1, era_predict = Var2) %>% tbl_df()
# Function to truncate data
truncate_data <- function(dat, quant = 0.5, subtract_value = 1){
my_quantile = quant
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat$size0.5 <- size0.5
dat <- dat %>% filter(size1mm >= size0.5)
# Need to subtract minimum size so that I can use a distribution appropriately
dat <- dat %>%
mutate(size_min = min(size1mm) - subtract_value,
size_centered = size1mm - size_min)
}
dat <- waraDF %>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
dat <- waraDF %>% filter(sampleArea == "Wara.B")
start_time <- proc.time()
jm = pooled_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size1mm, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
dat <- waraDF %>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
start_time <- proc.time()
jm = pooled_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$siz, breaks = 20, freq=FALSE)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
wara_coda_summary <- summary(zm)
wara_coda_quantile <- data.frame(wara_coda_summary$quantile) %>%
mutate(sp = "CHFU",
param = c("alpha", "beta", "sigma"))
coda_summary <- summary(zm)
wara_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "CHFU",
param = rownames(coda_summary$quantile))
summary(zm)
dat <- waraDF #%>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
start_time <- proc.time()
jm = pooled_model(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
dat <- waraDF %>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
start_time <- proc.time()
jm = model_jags(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
wara_coda_summary <- summary(zm)
wara_coda_quantile <- data.frame(wara_coda_summary$quantile) %>%
mutate(sp = "CHFU",
param = c("alpha", "beta", "sigma"))
coda_summary <- summary(zm)
wara_coda_quantile <- data.frame(coda_summary$quantile) %>%
mutate(sp = "CHFU",
param = rownames(coda_summary$quantile))
n.adapt <- 3000
n.update <- 3000
n.iter <- 3000
n_chains <- 2
era_predict <- c(0,1)
pred_df <- expand.grid(thc_predict, era_predict) %>%
rename(thc_predict = Var1, era_predict = Var2) %>% tbl_df()
truncate_data <- function(dat, quant = 0.5, subtract_value = 1){
my_quantile = quant
size0.5 <- dat %>% filter(era == "past") %>%
summarise(size0.5 = quantile(size1mm, probs = my_quantile)) %>% unlist(use.names = FALSE)
dat$size0.5 <- size0.5
dat <- dat %>% filter(size1mm >= size0.5)
# Need to subtract minimum size so that I can use a distribution appropriately
dat <- dat %>%
mutate(size_min = min(size1mm) - subtract_value,
size_centered = size1mm - size_min)
}
dat <- waraDF %>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
dat %>% count(era)
start_time <- proc.time()
jm = model_jags(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
wara_coda_summary <- summary(zm)
wara_coda_quantile <- data.frame(wara_coda_summary$quantile) %>%
mutate(sp = "CHFU",
param = c("alpha", "beta", "sigma"))
dat <- waraDF #%>% filter(sampleArea == "Wara.B")
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat <- truncate_data(dat, subtract_value = 2)
dat %>% ggplot(aes(size1mm)) + geom_histogram(binwidth = 1) + facet_wrap(~ era)
dat %>% count(sampleArea, era)
start_time <- proc.time()
jm = model_jags(dat = dat, iter_adapt = n.adapt, iter_update = n.update, n_chains = n_chains)
zm = coda.samples(jm, variable.names = c("alpha", "beta", "sigma"),
n.iter = n.iter, n.thin = 1)
zj = jags.samples(jm, variable.names = c("alpha", "beta", "sigma", "y.new", "p.mean", "p.sd", "p.discrep"),
n.iter = n.iter, n.thin = 1)
end_time <- proc.time()
end_time - start_time
#Produce a summary table for the parameters.
summary(zm)
exp(summary(zm)$stat[1]) # size intercept (past)
summary(zm)$stat[2]
dat %>% group_by(era) %>% summarise(median(size1mm))
median_change(dat)
plot(zm)
gelman.diag(zm, multivariate = F)
mean(zj$p.mean)
mean(zj$p.sd)
mean(zj$p.discrep)
hist(dat$size_centered, breaks = 20, freq=FALSE)
lines(density(zj$y.new), col="red")
mean(zj$p.mean)
mean(zj$p.sd)
